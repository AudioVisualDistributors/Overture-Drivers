// DO NOT EDIT THIS FILE UNLESS FIXING A BUG!

//------------------------------------------------------------------------------------------ CONSTANTS
const CMD_DEFER_TIME = 3000         // Timeout when using commandDefer
const POLL_PERIOD = 5000            // Polling function interval
const TICK_PERIOD = 5000            // In-built tick interval
const TCP_TIMEOUT = 30000           // Will timeout after this length of inactivity
const TCP_RECONNECT_DELAY = 5000    // How long to wait before attempting to reconnect

let host
exports.init = _host => {
    host = _host
}

exports.createDevice = base => {
    const logger = base.logger || host.logger
    let config
    let tcpClient
    const ir_codes = require('./ir_codes.json')

    //------------------------------------------------------------------------- STANDARD SDK FUNCTIONS
    function setup(_config) {
        config = _config
        base.setTickPeriod(TICK_PERIOD)
        // Register polling functions
        const defaults = {period: POLL_PERIOD, enablePollFn: isConnected, startImmediately: true}
        base.setPoll({...defaults, action: 'keepAlive'})

        // Populate IR_Commands enum from ir_codes.json file
        base.getVar('IR_Commands').enums = ['Idle'].concat(Object.keys(ir_codes))
    }

    function start() {
        initTcpClient()
    }

    function tick() {
        if (!tcpClient) initTcpClient()
    }

    function disconnect() {
        base.getVar('Status').string = 'Disconnected'
    }

    function stop() {
        disconnect()
        tcpClient && tcpClient.end()
        tcpClient = null
        base.stopPolling()
        base.clearPendingCommands()
    }

    function initTcpClient() {
        if (tcpClient) return // Do nothing if tcpClient already exists

        tcpClient = host.createTCPClient()
        tcpClient.setOptions({
            receiveTimeout: TCP_TIMEOUT,
            autoReconnectionAttemptDelay: TCP_RECONNECT_DELAY
        })

        tcpClient.on('connect', () => {
            logger.silly('TCPClient connected')
            base.getVar('Status').string = 'Connected'
            base.startPolling()
        })

        tcpClient.on('data', data => {
            onFrame(data.toString())
        })

        tcpClient.on('close', () => {
            logger.silly('TCPClient closed')
            disconnect() // Triggered on timeout, this allows auto reconnect
        })

        tcpClient.on('error', err => {
            logger.error(`TCPClient: ${err}`)
            stop() // Throw out the tcpClient and get a fresh connection
        })

        tcpClient.connect(config.port, config.host)
    }

    //-------------------------------------------------------------------------- SEND/RECEIVE HANDLERS
    function send(data) {
        logger.silly(`TCPClient send: ${data}`)
        return tcpClient && tcpClient.write(data)
    }

    function sendDefer(data) {
        base.commandDefer(CMD_DEFER_TIME)
        if (!send(data)) base.commandError('Data not sent')
    }

    function onFrame(data) {
        let pending = base.getPendingCommand()
        if (pending && pending.action === 'sendCommand') {
            const cmdName = base.getVar('IR_Commands').enums[pending.params.Index]
            logger.debug(`onFrame (pending = ${cmdName}): ${data}`)
            base.commandDone()
        }
        if (pending && pending.action === 'keepAlive') {
            base.commandDone()
        }
        else {
            logger.warn(`onFrame data not processed: ${data}`)
        }
    }

    //------------------------------------------------------------------------------- DEVICE FUNCTIONS
    function sendCommand(params) {
        let name = base.getVar('IR_Commands').enums[params.Index]
        let code = ir_codes[name]
        if (code) {
            sendDefer(`sendir,${config.module}:${config.ir_port},${code}\r`)
            base.getVar('IR_Commands').value = params.Index
            setImmediate(() => {
                base.getVar('IR_Commands').value = 0 // Set back to idle
            })
        }
        else {
            logger.error(`Invalid command index sent to function sendCommand: ${params.Index}`)
        }
    }

    function keepAlive() {
        sendDefer('getversion\r')
    }

    //------------------------------------------------------------------------------- HELPER FUNCTIONS
    function isConnected() {
        return base.getVar('Status').string == 'Connected'
    }

    //----------------------------------------------------------------------------- EXPORTED FUNCTIONS
    return {
        setup,
        start,
        stop,
        tick,
        sendCommand,
        keepAlive
    }
}
